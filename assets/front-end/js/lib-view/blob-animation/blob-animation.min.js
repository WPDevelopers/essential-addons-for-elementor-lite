/**
 * Blob Image Mask Library
 * Automatically creates SVG morphing masks for images
 * Requires GSAP library
 *
 * @version 3.0.0
 */

class BlobImageMask {
  constructor(selector, options = {}) {
    // Selector is required
    if (!selector) {
      throw new Error('BlobImageMask: Selector is required. Please provide a valid CSS selector, jQuery object, or DOM element.');
    }

    this.selector = selector;
    this.options = {
      duration: 3,
      ease: 'power2.inOut',
      repeat: -1,
      stagger: 0.5,
      autoStart: true,
      viewBox: '0 0 521 531',
      preserveAspectRatio: 'none',
      paths: [
        "M380.045 96.0397C432.405 102.966 501.969 126.823 517.304 167.611C532.638 208.783 493.741 266.502 460.455 329.607C427.169 392.713 399.493 460.821 346.759 497.761C293.651 535.085 215.859 541.242 159.011 510.074C101.789 479.291 65.5105 411.568 40.0785 346.538C14.2724 281.893 -0.313612 219.942 0.808391 151.834C1.93039 83.7264 18.7604 9.46198 64.3885 1.38139C110.017 -6.6992 184.069 51.4041 238.673 75.6459C292.903 99.5028 328.059 89.4983 380.045 96.0397Z",
        "M420.123 85.234C465.789 95.123 510.456 135.678 515.234 185.456C520.012 235.234 475.123 294.567 435.678 365.234C396.234 435.901 361.456 518.234 305.789 545.123C250.123 572.012 173.456 553.456 115.234 515.678C57.012 477.901 17.234 421.234 5.678 358.456C-5.878 295.678 10.789 226.789 45.234 168.123C79.678 109.456 131.901 61.012 185.234 45.678C238.567 30.345 293.012 48.123 345.678 58.234C398.345 68.345 374.456 75.345 420.123 85.234Z",
        "M350.234 120.456C415.678 115.234 485.123 140.789 505.456 195.234C525.789 249.678 496.234 323.456 455.789 385.123C415.345 446.789 364.012 496.234 295.456 520.789C226.901 545.345 141.123 545.012 85.789 515.234C30.456 485.456 5.123 426.234 15.234 365.789C25.345 305.345 70.901 243.678 125.234 195.456C179.567 147.234 242.678 112.456 305.123 105.789C367.567 99.123 284.789 125.678 350.234 120.456Z",
        "M395.678 110.789C445.234 125.456 485.789 165.234 510.123 215.678C534.456 266.123 542.567 326.234 515.234 375.456C487.901 424.678 425.234 462.012 365.789 485.234C306.345 508.456 250.123 517.567 195.456 505.789C140.789 494.012 87.678 461.345 55.234 415.678C22.789 370.012 11.123 311.345 25.456 255.234C39.789 199.123 80.012 145.567 135.234 115.456C190.456 85.345 260.678 78.678 325.234 95.234C389.789 111.789 346.123 96.123 395.678 110.789Z",
        "M365.234 135.678C405.789 145.234 440.123 175.456 460.234 215.789C480.345 256.123 486.234 306.567 470.789 350.234C455.345 393.901 418.567 430.789 375.234 455.678C331.901 480.567 282.456 493.456 235.789 485.234C189.123 477.012 145.234 447.678 115.456 405.234C85.678 362.789 70.012 307.234 75.234 254.567C80.456 201.901 106.567 152.123 145.234 125.456C183.901 98.789 235.123 95.234 285.678 105.789C336.234 116.345 324.678 126.123 365.234 135.678Z"
      ],
      ...options
    };

    this.timelines = [];
    this.isPlaying = true;
    this.currentSpeed = 1;
    this.uniqueId = this.generateUniqueId();

    if (this.options.autoStart) {
      this.init();
    }
  }

  /**
   * Generate unique ID for SVG elements
   */
  generateUniqueId() {
    return 'blob-' + Math.random().toString(36).substring(2, 11);
  }

  /**
   * Create SVG morphing structure for an image
   */
  createSVGStructure(imageElement, uniqueId) {
    // Get image source
    const imageSrc = imageElement.src || imageElement.getAttribute('href') || '';

    // Create wrapper div
    const wrapper = document.createElement('div');
    wrapper.className = 'ekit-morphing-wrapper';
    wrapper.setAttribute('data-morphing-id', uniqueId);

    // Create SVG structure
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', this.options.viewBox);
    svg.setAttribute('preserveAspectRatio', this.options.preserveAspectRatio);
    svg.setAttribute('class', 'ekit-custom-svg');

    // Create clipPath
    const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
    clipPath.id = `shape-morphing-${uniqueId}`;

    // Create path element
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', this.options.paths[0]); // Start with first path

    clipPath.appendChild(path);

    // Create group with clipping
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.setAttribute('clip-path', `url(#shape-morphing-${uniqueId})`);

    // Create image element
    const svgImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
    svgImage.setAttribute('class', 'ekit-morphing-image');
    svgImage.setAttribute('href', imageSrc);
    svgImage.setAttribute('preserveAspectRatio', this.options.preserveAspectRatio);
    svgImage.setAttribute('width', '100%');
    svgImage.setAttribute('height', '100%');

    // Assemble SVG
    group.appendChild(svgImage);
    svg.appendChild(clipPath);
    svg.appendChild(group);
    wrapper.appendChild(svg);

    return { wrapper, path };
  }

  /**
   * Initialize the blob morphing effect
   */
  init() {
    if (typeof gsap === 'undefined') {
      console.error('BlobImageMask: GSAP library is required');
      return;
    }

    let elements;

    // Handle different selector types
    if (typeof $ !== 'undefined' && this.selector instanceof $) {
      // jQuery object
      elements = this.selector.get();
    } else if (this.selector instanceof NodeList || this.selector instanceof HTMLCollection) {
      // NodeList or HTMLCollection
      elements = Array.from(this.selector);
    } else if (this.selector instanceof Element) {
      // Single DOM element
      elements = [this.selector];
    } else if (typeof this.selector === 'string') {
      // String selector
      elements = document.querySelectorAll(this.selector);
    } else if (this.selector && typeof this.selector === 'object' && this.selector.length !== undefined) {
      // jQuery-like object (has length property)
      elements = Array.from(this.selector);
    } else {
      throw new Error('BlobImageMask: Invalid selector type: ' + typeof this.selector);
    }

    if (!elements || elements.length === 0) {
      throw new Error(`BlobImageMask: No elements found with selector: "${this.selector}". Please check your selector or ensure elements exist in the DOM.`);
    }

    elements.forEach((element, index) => {
      this.processImageElement(element, index);
    });

    console.log(`BlobImageMask: Processed ${elements.length} images with morphing masks`);
    return this;
  }

  /**
   * Process an image element and create morphing mask
   */
  processImageElement(imageElement, index) {
    // Generate unique ID for this instance
    const uniqueId = this.generateUniqueId();

    // Create SVG structure
    const { wrapper, path } = this.createSVGStructure(imageElement, uniqueId);

    // Copy image styles to wrapper
    const computedStyle = window.getComputedStyle(imageElement);
    wrapper.style.width = computedStyle.width;
    wrapper.style.height = computedStyle.height;
    wrapper.style.display = computedStyle.display;
    wrapper.style.position = computedStyle.position;
    wrapper.style.margin = computedStyle.margin;
    wrapper.style.padding = computedStyle.padding;

    // Replace original image with SVG wrapper
    imageElement.parentNode.insertBefore(wrapper, imageElement);
    imageElement.style.display = 'none'; // Hide original image

    // Initialize morphing animation
    this.initMorphing(path, index);
  }

  /**
   * Initialize morphing animation for a path element
   */
  initMorphing(pathElement, index) {
    // Create timeline for this element
    const timeline = gsap.timeline({
      repeat: this.options.repeat,
      delay: index * this.options.stagger,
      ease: this.options.ease
    });

    // Add morphing animations
    this.options.paths.forEach(path => {
      timeline.to(pathElement, {
        attr: { d: path },
        duration: this.options.duration,
        ease: this.options.ease
      });
    });

    this.timelines.push(timeline);
  }



  /**
   * Play the animation
   */
  play() {
    gsap.globalTimeline.resume();
    this.isPlaying = true;
    return this;
  }

  /**
   * Pause the animation
   */
  pause() {
    gsap.globalTimeline.pause();
    this.isPlaying = false;
    return this;
  }

  /**
   * Toggle play/pause
   */
  toggle() {
    if (this.isPlaying) {
      this.pause();
    } else {
      this.play();
    }
    return this;
  }

  /**
   * Set animation speed
   */
  setSpeed(speed) {
    this.currentSpeed = speed;
    gsap.globalTimeline.timeScale(speed);
    return this;
  }

  /**
   * Update paths and restart animation
   */
  updatePaths(newPaths) {
    this.options.paths = newPaths;
    this.destroy();
    this.init();
    return this;
  }

  /**
   * Destroy all timelines
   */
  destroy() {
    this.timelines.forEach(timeline => {
      timeline.kill();
    });
    this.timelines = [];
    return this;
  }
}

// No auto-initialization - selector is required

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = BlobImageMask;
}

// Global export
window.BlobImageMask = BlobImageMask;